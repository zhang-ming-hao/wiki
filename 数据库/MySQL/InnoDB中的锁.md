# InnoDB中的锁
在数据库操作中，经常会有并发的情况，数据库会使用锁来解决并发的问题。那么并发会有什么问题，事务和锁又是如何解决这些问题的呢？  
大学的时候的数据库理论已经还给老师了，这里以MySQL的InnoDB引擎为例，对数据库的并发问题进行总结。

## 事务

讨论并发，首先要讨论事务，因为事务是数据库并发的基本单位。事务由一个有限的数据库操作序列构成，具有如下特性：
* 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。  
举个栗子来解释，比如银行从帐户A向账户B中转100块钱，先从帐户A中扣除了100元，但是向账户B中增加100元失败了，那么整个事务就失败了，帐户A的钱不会真正被扣除。
* 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。  
我们不去扩展开讨论完整性约束，说白了，完整性约束就是说数据的结构和表结构是一致的，并且还要满足什么主键、外键的约束。能保存到数据库中的数据，都是满足完整性约束的，也就是说是一致的。
* 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。  
正是因为这条特性，造成了一系列的并发问题。
* 持久性（Durability）：已被提交的事务对数据库的修改应该保存在数据库中。

一个事务可以包含四种操作：
* 开始事务：开始一个新的事务，在很多数据库引擎中，事务在插入、更新和删除时会自动开始事务。
* 执行SQL语句：执行一个或多个SQL语句。
* 提交事务：当所有SQL语句执行成功时，新更改保存到数据库。
* 回滚事务：当某SQL语句执行失败时，将数据回滚到开始事务时的状态。

## 并发的问题
上面说了，事务不是排他的，隔离性允许多个事务同时执行，这就会造成以下并发的问题：
* 更新丢失  
  
假如我们有一个计数器，记录某一事件的发生次数。当A发生了这一事件，要去把计数器加1，此时B也发生了该事件，也要去把计数器加1，他们操作的时间先后如下：  

时间 | 事务A | 事务B
:--: | :--: | :--:
T1 | 开始事务 | 开始事务
T2 | 读取计数器 | 读取计数器
T3 | 计数器加1 |
T4 | | 计数器加1
T5 | 提交 | 提交
因为事务A还没有提交，事务B就对原来的值加1，使得两个事务提交的值都是原来的值加1，事务A的更新丢失了。

* 脏读  

同样是上一个例子，如果时间顺序改变一下：

时间 | 事务A | 事务B
:--: | :--: | :--:
T1 | 开始事务 | 开始事务
T2 | 读取计数器 | 
T3 | 计数器加1 |
T4 | | 读取计数器
T5 | | 计数器加1
T6 | 提交 | 提交



## 锁

## 死锁