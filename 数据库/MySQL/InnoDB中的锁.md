[TOC]

# InnoDB中的锁
在数据库操作中，经常会有并发的情况，数据库会使用锁来解决并发的问题。那么并发会有什么问题，事务和锁又是如何解决这些问题的呢？  
大学的时候的数据库理论已经还给老师了，这里以MySQL的InnoDB引擎为例，对数据库的并发问题进行总结。

## 事务

讨论并发，首先要讨论事务，因为事务是数据库并发的基本单位。事务由一个有限的数据库操作序列构成，具有如下特性：
* 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。  
举个栗子来解释，比如银行从帐户A向账户B中转100块钱，先从帐户A中扣除了100元，但是向账户B中增加100元失败了，那么整个事务就失败了，帐户A的钱不会真正被扣除。
* 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。  
我们不去扩展开讨论完整性约束，说白了，完整性约束就是说数据的结构和表结构是一致的，并且还要满足什么主键、外键的约束。能保存到数据库中的数据，都是满足完整性约束的，也就是说是一致的。
* 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。  
正是因为这条特性，造成了一系列的并发问题。
* 持久性（Durability）：已被提交的事务对数据库的修改应该保存在数据库中。

一个事务可以包含四种操作：
* 开始事务：开始一个新的事务，在很多数据库引擎中，事务在插入、更新和删除时会自动开始事务。
* 执行SQL语句：执行一个或多个SQL语句。
* 提交事务：当所有SQL语句执行成功时，新更改保存到数据库。
* 回滚事务：当某SQL语句执行失败时，将数据回滚到开始事务时的状态。

## 并发的问题

上面说了，事务不是排他的，隔离性允许多个事务同时执行，这就会造成以下并发的问题：
* 更新丢失  
  
假如我们有一个计数器，记录某一事件的发生次数。当A发生了这一事件，要去把计数器加1，此时B也发生了该事件，也要去把计数器加1，他们操作的时间先后如下：  

时间 | 事务A | 事务B
:--: | :--: | :--:
T1 | 开始事务 | 开始事务
T2 | 读取计数器 | 读取计数器
T3 | 计数器加1 |
T4 | | 计数器加1
T5 | 提交 | 提交

因为事务A还没有提交，事务B就对原来的值加1，使得两个事务提交的值都是原来的值加1，事务A的更新丢失了。

* 脏读  

同样是上一个例子，如果时间顺序改变一下：

时间 | 事务A | 事务B
:--: | :--: | :--:
T1 | 开始事务 | 开始事务
T2 | 读取计数器 | 
T3 | 计数器加1 |
T4 | | 读取计数器
T5 | 提交 | 计数器加1
T6 |  | 提交

事务A虽然已经对计数加1了但在提交之前事务B读取了计数器的值，此时事务B读到的值为脏数据。

* 不可重复读

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。如：

时间 | 事务A | 事务B
:--: | :--: | :--:
T1 | 开始事务 | 开始事务
T2 | 读取计数器 | 
T3 | | 读取计数器
T4 |  | 计数器加1
T5 |  | 提交
T6 | 读取计数器 | 
T7 | 提交 | 

事务A两次读取到的值不一样。不过，这种现象并不一定就是问题，在某些情况下，我们认为第二次读就应该读到事务B提交的数据。

* 幻读  

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。  
幻读的道理和不可重复读是一样的，只是不可重复读读取是同一个数据，而幻读是读取到的数据的行数发生改变。

## 锁

既然事务并发有这么多的问题，大多是由于事务的隔离性造成的。与多线程并行需要使用各种信号量同步一样，事务和事务之间也需要锁进行同步。这就是锁。广义上，锁分为乐观锁和悲观锁。乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据，狭义上，乐观锁不是锁，而是一套针对具体问题制定的可避免并发问题方案。悲观锁与乐观锁相反，当一个用户使用数据时，不允许别人使用自己的数据。数据库中提供的锁都是悲观锁，我们讨论锁，也只对悲观锁进行讨论。

从锁定的级别上，锁可以分成两类：
* 行级锁：对表中的某些行加锁
* 表级锁：对整个表加锁

从锁的作用上，锁也可以分成两类：
* 共享锁（S锁）：加锁的事务可对数据进行读写，没有锁的事务只能读，不能写
* 排他锁（X锁）：加锁的事务可对数据进行读写，没有锁的事务不能读写

### 行级锁

执行SQL语句时，如果SQL语句为INSERT、UPDATE或DELETE时，InnoDB自动对满足条件的数据加行级排他锁，但如果是SELECT，则需要显示的指定加共享锁还是排他锁。

```sql
SELECT ... LOCK IN SHARE MODE;   # 行级共享锁
SELECT ... FOR UPDATE;           # 行级排他锁
```

要想解除行级锁，只需要什么COMMIT或ROLLBACK结束当前事务即可。

### 表级锁

表级锁没有自动添加的方式，添加和解除都需要显示的进行。加锁使用LOCK TABLES语句：

```sql
LOCK TABLES 表名 READ;        # 共享锁
LOCK TABLES 表名 WRITE;       # 排他锁
```

当有多个表需要加锁时，最好一次性给所有表加锁，否则可能会造成死锁，如：
时间 | 事务A | 事务B
:--: | :--:|:--:
T1 | BEGIN; | BEGIN;
T2 | LOCK TABLES a WRITE; | LOCK TABLES b WRITE;
T3 | LOCK TABLES b WRITE; | LOCK TABLES a WRITE;
这样两个事务都进入阻塞状态，即得不到想要的锁，也不能进行解锁。当然，这可以通过超时机制进行控制，但最好还是同时对所有表加锁。对多表加锁时，可以分别指定每张表加锁的类型，如：

```sql
LOCK TABLES a WRITE, b READ;
```

事务处理完成后，需要进行解锁，解锁不能对单表进行，只能一次性解锁所有加锁的表：

```sql
UNLOCK TABLES;
```

__注：事务完成后必须解锁，COMMIT和ROLLBACK都不能自动解除表级锁。若没有解锁而断开链接，则会造成死锁。__

## 死锁

当某表被死锁后，可以通过以下方式解决：

```sql
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
KILL 上面查询结果中trx_mysql_thread_id
```

## 事务隔离级别

在锁之上，InnoDB还提供了的事务隔离级别，实现了一些事务自动加锁的机制。一共有4种级别：

* 读取未提交内容（Read Uncommitted）：  

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。这显然不是我们想要的，所以这个级别很少被使用。

* 读取提交内容（Read Committed）：  

这是大多数数据库系统的默认隔离级别（但不是InnoDB默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别不能避免所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

* 可重读（Repeatable Read）：

顾名思义，这是为了解决不可重复读。理论上事务T在数据读取时，必须增加行级共享锁，直到事务结束；事务T在修改数据过程中，必须增加行级排他锁，直到数据结束。这是InnoDB默认的隔离级别。  

但在MySQL5.7的实际测试中，发现现象与理论不符，测试过程如下：

时间 | 事务A | 事务B
:--: | :--: | :--:
T1 | BEGIN | BEGIN
T2 | SELECT num FROM lock_test WHERE id=1;（结果为1） |
T3 | | UPDATE lock_test SET num=0;（结果为0）
T3 | | COMMIT;
T4 | SELECT num FROM lock_test WHERE id=1;（结果仍为1）|
T5 | COMMIT; |
T6 | SELECT num FROM lock_test WHERE id=1;（结果为0） |

首先，如果事务A在读取数据时加了共享锁，那么事务B是不能进行UPDATE操作的；其次，事务B在COMMIT后，事务A仍然读到原来的结果。只有事务A结束之后，再读才能读到真实的结果。感觉像是事务A读数据时并非加锁，而是创建了数据的快照。

* 可串行化（Serializable）：

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。只是这种级别大大降低了并发性能，也不被大多数据人使用。

有了上面的理论，感觉InnoDB默认的级别不太适应一些应用场合，此时需要修改它的默认级别为Read Committed。设置方式为：

```sql
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
```

如，只想将当前会话的级别修改为READ COMMITTED：

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

全局的修改则为：

```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

当然，也可以在my.cnf中进行修改mysqld下的transaction_isolation，它可先的值与在SQL语句中不同：
READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE

